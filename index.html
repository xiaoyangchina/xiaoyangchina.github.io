<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  

  
  <title>XiaoYang的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="XiaoYang的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="XiaoYang的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="XiaoYang的博客">
  
    <link rel="alternate" href="/atom.xml" title="XiaoYang的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
<link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">XiaoYang的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">机器学习和Android</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Git使用教程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/14/Git使用教程/" class="article-date">
  <time datetime="2018-11-14T14:00:37.000Z" itemprop="datePublished">2018-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/14/Git使用教程/">Git使用教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><ol>
<li>git是一个分布式版本控制系统。</li>
<li><p>创建git库<br> a) 创建一个项目根目录</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir demo</span><br><span class="line">cd demo/</span><br></pre></td></tr></table></figure>
<p> b) 初始化git库</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p> 当前demo根目录初始化为git库，通过<code>ls -la</code>命令可以看到当前目录下生成了一个<code>.git</code>的隐藏文件夹。<br> <img src="https://github.com/xiaoyangchina/images/blob/master/blog_xiaoyangchina/other/git_init.png?raw=true" alt=""></p>
</li>
<li><p>添加文件<br>在根目录下创建一个<code>readme.txt</code>的文件，内容是<code>hello,git!</code>。接下来我们使用<code>add</code>命令将文件添加到文件库中。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add readme.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>commit</code>命令向git库进行提交</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;commit readme file&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请务必填写提交内容相关的说明文字，即引号中的内容 </p>
</blockquote>
<p> commit操作成功后你可以看到控制台输出如下<br> <img src="https://github.com/xiaoyangchina/images/blob/master/blog_xiaoyangchina/other/git_commit.png?raw=true" alt=""></p>
<blockquote>
<p>为什么git添加和提交要分成两步呢？这样做你就可以在多次<code>add</code>操作之后使用一次<code>commit</code>来统一提交。</p>
</blockquote>
</li>
<li><p>查看文件修改状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>可以看到当前在master分支，没有任何提交。<br>接下来我们对文件做一些修改，把readme.txt文件中内容改成“hello, i am git!”.再次使用‘status’命令查看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">		(use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">		(use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working 			directory)</span><br><span class="line"></span><br><span class="line">		modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>这里的输出信息可以看到：<br>a) 我们在master分支<br>b) 发生了变化没有暂存的内容可以通过括号里面的方法处理，一个是<code>add</code>操作用来做<code>commit</code>，一个是使用<code>checkout</code>操作来消除之前你修改的这些变化。<br>c) 支持修改内容是readme.txt<br>d) 最后告诉大家你可以使用<code>add</code>和<code>commit</code>命令把没提交的内容提交了<br>但是，如果我们想要看看我们修改了什么，怎么办？使用‘diff’命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$git diff</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index f100ad9..bdca168 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-hello,git!</span><br><span class="line">+hello,i am git!</span><br></pre></td></tr></table></figure>
<p>这里就很明确的告诉了我们，文件内容发生了什么变化。<br>接下来我们执行<code>add</code>和<code>commit</code>命令进行提交了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$git add readme.txt</span><br><span class="line">git commit -m &quot;change to &apos;i am git&apos;&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>版本间切换<br>我们已经提交了两次内容，使用<code>log</code>命令查看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">commit 46687d7ad6475f296157b3efbf62e55be076f327</span><br><span class="line">Author: xiaoyang &lt;yangyang.xiao@263net.com&gt;</span><br><span class="line">Date:   Wed Nov 14 11:19:50 2018 +0800</span><br><span class="line"></span><br><span class="line">  	change to &apos;i am git&apos;</span><br><span class="line"></span><br><span class="line">commit 970c3c15e9c0dec4692b9d936abc90667f91b23f</span><br><span class="line">Author: xiaoyang &lt;yangyang.xiao@263net.com&gt;</span><br><span class="line">Date:   Wed Nov 14 10:26:59 2018 +0800</span><br><span class="line"></span><br><span class="line">  	commit readme file</span><br></pre></td></tr></table></figure>
<p>我们可以看到两次提交的log了，如果我想把当前的版本回退到之前的那个怎么办？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 970c3c1</span><br><span class="line">HEAD is now at 970c3c1 commit readme file</span><br></pre></td></tr></table></figure>
<p>查看一下文件内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt </span><br><span class="line">hello,git!</span><br></pre></td></tr></table></figure>
<p>是不是已经变回了最早的版本了。查看下log。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 970c3c15e9c0dec4692b9d936abc90667f91b23f</span><br><span class="line">Author: xiaoyang &lt;yangyang.xiao@263net.com&gt;</span><br><span class="line">Date:   Wed Nov 14 10:26:59 2018 +0800</span><br><span class="line"></span><br><span class="line">  	commit readme file</span><br></pre></td></tr></table></figure>
<p>不过话说回来，我们又不想在这个版本了，想回到最新的版本怎么办？这是就需要查看操作记录然后找到最新版本提交产生的id，再使用<code>reset</code>命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$git reflog</span><br><span class="line">970c3c1 HEAD@&#123;0&#125;: reset: moving to 970c3c1</span><br><span class="line">46687d7 HEAD@&#123;1&#125;: commit: change to &apos;i am git&apos;</span><br><span class="line">970c3c1 HEAD@&#123;2&#125;: commit (initial): commit readme file</span><br><span class="line"></span><br><span class="line">$git reset --hard 46687d7</span><br><span class="line">HEAD is now at 46687d7 change to &apos;i am git&apos;</span><br><span class="line"></span><br><span class="line">$cat readme.txt </span><br><span class="line">hello,i am git!</span><br></pre></td></tr></table></figure>
</li>
<li><p>git add和git commit原理<br>我们先来看一下<em>.git</em>文件夹下面的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd .git/</span><br><span class="line">$ ls</span><br><span class="line">COMMIT_EDITMSG	branches	hooks		logs</span><br><span class="line">HEAD		config		index		objects</span><br><span class="line">ORIG_HEAD	description	info		refs</span><br></pre></td></tr></table></figure>
<p>其中HEAD是指向master的指针，index是暂存区(stage)。<br>当我们执行<code>git add</code>命令后，我们修改的内容就存入了暂存区，你可以多次执行<code>git add</code>命令，它会全部存储在暂存区，最后我们执行<code>git commit</code>命令把暂存区的内容全部提交到我们master上去。</p>
</li>
<li><p>修改撤销<br>修改撤销一般分为未执行<code>git add</code>撤销和已执行撤销<br>未执行：通过<code>git checkout -- readme.txt</code>命令来恢复成与暂存区或分支版本一致的内容。<br>已执行：执行过之后，你修改的内容已存入暂存区，在这种情况下你需要先执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD readme.txt</span><br></pre></td></tr></table></figure>
<p>该命令执行作用是将暂存区内的东西回退到非暂存状态，然后在按照未执行过<code>git add</code>命令的方法来处理，即执行<code>git checkout -- readme.txt</code>。</p>
</li>
<li><p>删除文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm filename</span><br><span class="line">git commit -m &quot;remove xxx file&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加远程仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/xiaoyangperfect/gitlearn.git</span><br></pre></td></tr></table></figure>
<p>这时你已经连接了git仓库，然后把内容推送到仓库中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
</li>
<li><p>分支管理<br>首先我们创建一个新的分支<em>dev</em>，创建并切换到新分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure>
<p>使用<code>git branch</code>命令查看当前分支状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>
<p>然后我们修改readme文件并提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">hello,i am git!</span><br><span class="line">test branch</span><br></pre></td></tr></table></figure>
<p>切换回master分支并查看readme文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ cat readme</span><br><span class="line">hello,i am git!</span><br></pre></td></tr></table></figure>
<p>使用<em>merge</em>进行合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating 46687d7..5e7324d</span><br><span class="line">Fast-forward</span><br><span class="line"> 		readme.txt | 1 +</span><br><span class="line"> 		1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p>合并成功后，我们就可以删除dev分支了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">$ git brach</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>
<p>如果我们创建了dev分支进行了修改，与此同时master也做了修改，我们合并时会发生什么问题？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">$ cat readme.txt </span><br><span class="line">hello,i am git!</span><br><span class="line">It&apos;s second line.</span><br><span class="line"></span><br><span class="line">$ git checkout dev</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line"></span><br><span class="line">$ cat readme.txt</span><br><span class="line">hello,i am git!</span><br><span class="line">I am on dev.</span><br><span class="line"></span><br><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line">$ git merge</span><br><span class="line"> Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict in readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>
<p>显而易见自动合并失败了，这个时候我们需要手动修改出错文件readme.txt，在文件中会有<em>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</em>和<em>=======</em>和<em>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</em>这部分是冲突内容，我们手动解决就好了，然后重新执行<code>add</code>和<code>commit</code>命令，删除dev分支。</p>
<p>使用<figure class="highlight plain"><figcaption><span>log --graph --pretty</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">12. Git标签</span><br><span class="line">	常用打标签命令有两种</span><br><span class="line">	```git tag v1.0</span><br></pre></td></tr></table></figure></p>
<p>在当前的提交处设置v1.0标签</p>
<figure class="highlight plain"><figcaption><span>tag v1.0 f0205317a9a16ee9bfb7a0098e96499ad6248f26```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在commit id为f0205317a9a16ee9bfb7a0098e96499ad6248f26处设置标签v1.0</span><br><span class="line">删除标签</span><br><span class="line">```git tag -d v1.0</span><br></pre></td></tr></table></figure>
<p>创建有信息的标签</p>
<figure class="highlight plain"><figcaption><span>tag -a v0.1 -m "version 0.1 released" 1094adb```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看指定标签</span><br><span class="line">```git show v0.1</span><br></pre></td></tr></table></figure>
<p>把标签推送到远程</p>
<figure class="highlight plain"><figcaption><span>push origin v0.1``或```git push origin --tags``</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">13. stash</span><br><span class="line">   当你在工作中手上有未完成的工作但又来了一个很重要的bug需要去处理怎么办？</span><br><span class="line">   我们可以先使用stash把未完成的工作存起来`git stash`,这个时候你使用`git status`可以看到我们的work tree是干净的，你就可以随意去切换分支工作了。</span><br><span class="line">   但当你fix掉了bug怎么恢复呢？</span><br></pre></td></tr></table></figure>
<p>$ git stash list<br>stash@{0}: WIP on master: f020531 merge dev conflicts<br><code>``
然后使用</code>git stash pop`,OK你的工作现场恢复了。</p>
<blockquote>
<p>使用<code>git stash apply stash@{0}</code>来单条恢复。</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="work-flow"><a href="#work-flow" class="headerlink" title="work flow"></a>work flow</h2><p><img src="https://github.com/xiaoyangchina/images/blob/master/blog_xiaoyangchina/other/HomePlusGitFlow.jpg?raw=true" alt=""><br>基本上Git的work flow就是图上所示。<br>Master分支是主分支，长期分支，用于代码发布，要求代码稳定，不可用于开发，每次发布版本创建相应Tag作为里程碑。版本发布的功能是由Develop分支已经完成测试的功能合并过来的。<br>Develop分支，长期分支，开发主分支，所有开发features都是在该分支上进行。它是比较先进的分支，拥有最新的功能，主分支要发布版本的功能来源于该分支上。该分支上所合并的功能代码要求是经过测试和code review的。<br>Hot Fix分支，短期分支，用于hot fix，由Master分支迁出，完成bug修复和测试后合并回Master分支，同时合并到Develop分支，然后删除。<br>小明和小红分支，属于feature分支，当有新功能开发时，可以在Develop上迁出一个功能分支，这里的小明或小红应该改成feature命名的分支，如果仅需要个人开发只需要创建一个本地分支即可，如果需要合作开发就创建远程分支，在功能开发完并完成功能测试后合并回Develop上，同时删除该分支。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/14/Git使用教程/" data-id="cjy3rwvvr000hd2rgfpyx4hsa" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Jetpack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/12/Jetpack/" class="article-date">
  <time datetime="2018-11-12T08:21:24.000Z" itemprop="datePublished">2018-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/12/Jetpack/">Jetpack</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Jetpack"><a href="#Jetpack" class="headerlink" title="Jetpack"></a>Jetpack</h1><h2 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h2><p>  Jetpack为什么会产生呢？<br>  我们用一个例子来说明：<br>  假设我们在使用一个社交软件，我们用到一个功能就是发送图片，一般流程是我们的app调用起相机或图片选择器，然后我们进行拍照或者选择图片，之后相机或图片选择器就把图片返回给我们app，这样来完成一个完整流程。但是有时候在我们操作过程中有可能回来一个其他的推送通知引起我们的注意比如短信、电话等。如果你在这个过程中接到电话去打电话了，那么在系统资源不足的情况下我们app的一些资源就会被回收。这种情况下，我们该怎么办？难道我们要在各个阶段都存储数据？我们有没有更好的办法？</p>
<h2 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h2><p>  首先我们不可能把所有的代码都写在Activity和Fragment中，因为无论是Activity还是Fragment你都不能拥有，它们是系统组件，仅仅是你的app和系统之间的粘合剂，它们随时都可能被系统回收掉。</p>
<h3 id="用模型来驱动view"><a href="#用模型来驱动view" class="headerlink" title="用模型来驱动view"></a>用模型来驱动view</h3><p>  模型是独立于view和app组件的，所以它们可以独立于app的生命周期而存在。<br>好处有两点：</p>
<ol>
<li>系统回收资源时不会丢失数据。</li>
<li>当没有网络时app仍然可以工作。<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2>下面来看一下框架设计：<img src="https://github.com/xiaoyangchina/images/blob/master/blog_xiaoyangchina/other/final-architecture.png?raw=true" alt=""></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/12/Jetpack/" data-id="cjy3rwvto0000d2rg8t6p5dez" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/09/算法/" class="article-date">
  <time datetime="2018-10-09T02:39:53.000Z" itemprop="datePublished">2018-10-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/09/算法/">算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>时间复杂度：最好O(n)最坏O(n^2)平均(n^2)<br>空间复杂度：O(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void sort() &#123;</span><br><span class="line">       int[] a = &#123;3, 2, 5, 7, 9 , 8, 6, 1&#125;;</span><br><span class="line">       for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">           boolean exchange = false;</span><br><span class="line">           for (int j = 0; j &lt; a.length - i - 1; j ++) &#123;</span><br><span class="line">               if (a[j] &gt; a[j+1]) &#123;</span><br><span class="line">                   int b = a[j];</span><br><span class="line">                   a[j] = a[j+1];</span><br><span class="line">                   a[j+1] = b;</span><br><span class="line">                   exchange = true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (!exchange) &#123;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       for (int x : a)</span><br><span class="line">           System.out.print(x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>时间复杂度：最好O(n)最坏O(n^2)平均(n^2)<br>空间复杂度：O(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void sort() &#123;</span><br><span class="line">    int[] a = &#123;3, 2, 5, 7, 9 , 8, 6, 1&#125;;</span><br><span class="line">    for(int i = 0; i &lt; (a.length-1); i++) &#123;</span><br><span class="line">        int minIndex = i;</span><br><span class="line">        for (int j = i+1; j &lt; a.length; j++) &#123;</span><br><span class="line">            if(a[minIndex] &gt; a[j]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(minIndex != i) &#123;</span><br><span class="line">            int b = a[i];</span><br><span class="line">            a[i] = a[minIndex];</span><br><span class="line">            a[minIndex] = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int x : a)</span><br><span class="line">        System.out.print(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>时间复杂度：最好O(n)最坏O(n^2)平均(n^2)<br>空间复杂度：O(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void sort() &#123;</span><br><span class="line">        int[] a = &#123;3, 2, 5, 7, 9 , 8, 6, 1&#125;;</span><br><span class="line">        for (int i = 1; i &lt; a.length; i++) &#123;</span><br><span class="line">            int b = a[i];</span><br><span class="line">            int j = i-1;</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; b &lt; a[j]) &#123;</span><br><span class="line">                a[j+1] = a[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+1] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int x : a)</span><br><span class="line">            System.out.print(x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>时间复杂度：O(nlog_2n)<br>空间复杂度：O(n)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public static void merge(int[] a, int[] b, int low, int high, int mid) &#123;</span><br><span class="line">        int i = low;</span><br><span class="line">        int j = mid + 1;</span><br><span class="line">        int k = i;</span><br><span class="line">        for (; i &lt;= mid &amp;&amp; j &lt;= high; k++) &#123;</span><br><span class="line">            if (a[i] &lt;= a[j]) &#123;</span><br><span class="line">                b[k] = a[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                b[k] = a[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (i &lt;= mid) &#123;</span><br><span class="line">            b[k] = a[i];</span><br><span class="line">            k++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (j &lt;= high) &#123;</span><br><span class="line">            b[k] = a[j];</span><br><span class="line">            k++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int n = low; n &lt;= high; n++) &#123;</span><br><span class="line">            a[n] = b[n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void sort(int[] a, int[] b, int low, int high) &#123;</span><br><span class="line">        if (low &lt; high) &#123;</span><br><span class="line">            int mid = (low + high) / 2;</span><br><span class="line">            sort(a, b, low, mid);</span><br><span class="line">            sort(a, b, mid + 1, high);</span><br><span class="line">            merge(a, b, low, high, mid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>时间复杂度：平均O(nlog_2n)； 最坏O(n^2)；最好(nlog_2n)<br>空间复杂度：O(nlog_2n)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static int partiton(int[] a, int low, int high) &#123;</span><br><span class="line">       int k = a[low];</span><br><span class="line">       while (high &gt; low) &#123;</span><br><span class="line">           while (high &gt; low &amp;&amp; a[high] &gt;= k) &#123;</span><br><span class="line">               high--;</span><br><span class="line">           &#125;</span><br><span class="line">           a[low] = a[high];</span><br><span class="line">           while (high &gt; low &amp;&amp; a[low] &lt;= k) &#123;</span><br><span class="line">               low++;</span><br><span class="line">           &#125;</span><br><span class="line">           a[high] = a[low];</span><br><span class="line">       &#125;</span><br><span class="line">       a[high] = k;</span><br><span class="line">       return high;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void qqSort(int[] a, int low, int high) &#123;</span><br><span class="line">       if (high &gt; low) &#123;</span><br><span class="line">           int index = partiton(a, low, high);</span><br><span class="line">           qqSort(a, low, index);</span><br><span class="line">           qqSort(a, index+1, high);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/09/算法/" data-id="cjy3rwvv8000ed2rgd0uzso1n" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/03/数据结构/" class="article-date">
  <time datetime="2018-10-03T04:15:33.942Z" itemprop="datePublished">2018-10-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>地址连续、读取随机、增删移位；插入移位概率(n/2)；删除移位(n-1/2)</p>
<h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p>地址随机、读取连续；<br>a) 插入操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next = p-&gt;next</span><br><span class="line">p-&gt;next = s</span><br></pre></td></tr></table></figure></p>
<p>b) 删除操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q = p-&gt;next</span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next</span><br><span class="line">free(q)</span><br></pre></td></tr></table></figure></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>先进后出</p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>顺序存储和链式存储</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><p>先进先出</p>
<h3 id="存储-1"><a href="#存储-1" class="headerlink" title="存储"></a>存储</h3><h4 id="顺序存储-1"><a href="#顺序存储-1" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>入队列移动队头、出队列移动队列尾；代表环形队列</p>
<h4 id="链式存储-1"><a href="#链式存储-1" class="headerlink" title="链式存储"></a>链式存储</h4><p>头指针和尾指针值相同队列尾空。</p>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h3 id="存储-2"><a href="#存储-2" class="headerlink" title="存储"></a>存储</h3><p>顺序存储、链式存储</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="存储-3"><a href="#存储-3" class="headerlink" title="存储"></a>存储</h3><p>定长线性表、顺序存储</p>
<h2 id="矩阵和广义表"><a href="#矩阵和广义表" class="headerlink" title="矩阵和广义表"></a>矩阵和广义表</h2><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>非线性结构</p>
<h3 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h3><p>一棵树由若干子树构成，子树又由若干子子树构成</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>1）节点和左右子树构成<br>2）第i层最多有2-(i-1)个节点<br>3）高度为k的二叉树最多有2-(k)-1个节点</p>
<h3 id="二叉树存储"><a href="#二叉树存储" class="headerlink" title="二叉树存储"></a>二叉树存储</h3><h4 id="顺序存储-2"><a href="#顺序存储-2" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>按层顺序依次存储</p>
<h4 id="链式存储-2"><a href="#链式存储-2" class="headerlink" title="链式存储"></a>链式存储</h4><p>二叉或三叉链表存储</p>
<h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><p>先序遍历、中序遍历、后续遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void order(Tree root) &#123;</span><br><span class="line">	if (root != null) &#123;</span><br><span class="line">        print(root-&gt;data)</span><br><span class="line">    	order(root-&gt;lchild)</span><br><span class="line">    	order(root-&gt;rchild)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>Itag-lchild-data-rchild-rtag</p>
<h3 id="最优二叉树-哈夫曼树"><a href="#最优二叉树-哈夫曼树" class="headerlink" title="最优二叉树(哈夫曼树)"></a>最优二叉树(哈夫曼树)</h3><p>带权路径最小的二叉树。</p>
<h3 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h3><h4 id="存储-4"><a href="#存储-4" class="headerlink" title="存储"></a>存储</h4><p>1）双亲表示法<br>2）孩子表示法<br>3）孩子兄弟表示法(二叉链表表示法)</p>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>先根和后根</p>
<h4 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h4><p>1）树、森林转化成二叉树<br>孩子兄弟表示法转化二叉树<br>2）二叉树转化成树或森林<br>孩子兄弟表示法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/03/数据结构/" data-id="cjy3rwvu40002d2rgcb2we2ye" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-机器学习-11-通过MNIST了解卷积神经网络" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/18/机器学习-11-通过MNIST了解卷积神经网络/" class="article-date">
  <time datetime="2018-05-18T10:09:32.000Z" itemprop="datePublished">2018-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/18/机器学习-11-通过MNIST了解卷积神经网络/">机器学习-11-通过MNIST了解卷积神经网络</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="通过MNIST了解卷积神经网络-CNN"><a href="#通过MNIST了解卷积神经网络-CNN" class="headerlink" title="通过MNIST了解卷积神经网络(CNN)"></a>通过MNIST了解卷积神经网络(CNN)</h3><blockquote>
<p>MNIST数据使用的是28*28像素的图片</p>
</blockquote>
<p>  卷积神经网络是当前图片分类最先进的模型。它是通过对图片像素应用一系列的过滤器从而提取到大量用于判定图片分类的高级特征。卷积神经网络一般由一下三部分组成：</p>
<ul>
<li>卷积层：它应用指定数目的卷积核到图片上。对于每个字区域，通过一系列的数学计算获取到一个特定值。卷积层会应用一个激活函数(<a href="#激活函数">下面会介绍</a>），实现非线性。一个卷积核就是一个特征。</li>
<li>池化层：用来减维。简单介绍下，池化过程就是，给一个filter比如2*2，应用一个算法比如max，每一个filter取其中最大值其他抛弃掉。</li>
<li><p>全连接层</p>
<p>卷积神经网络每一个卷积层后都会跟着一个池化层，在模型的最后会跟一个或多个全连接层，最后一层的全连接层的节点个数等于可能的分类数。使用softmax方法把每个节点的值缩放到0-1之间，所有的节点相加总和是1.</p>
</li>
</ul>
<h3 id="构建CNN模型"><a href="#构建CNN模型" class="headerlink" title="构建CNN模型"></a>构建CNN模型</h3><ol>
<li><a href="#卷积层1">卷积层1</a>.应用32个5*5的卷积核，激活函数使用ReLU。</li>
<li><a href="#池化层1">池化层1</a>.max pooling，2*2filter，步长2</li>
<li><a href="#卷积层2和池化层2">卷积层2</a>.64个5*5的卷积核，激活函数ReLU</li>
<li><a href="#卷积层2和池化层2">池化层2</a>.max pooling，2*2filter，步长2</li>
<li><a href="#全连接层">全连接层1</a>.1024个神经元</li>
<li><a href="#Logits Layer">全连接层2</a>。10个神经元</li>
</ol>
<h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><h4 id="输入层"><a href="#输入层" class="headerlink" title="输入层"></a>输入层</h4><p><code>input_layer = tf.reshape(features[&quot;x&quot;], [-1, 28, 28, 1])</code><br>tf.reshape可以把数据按指定的样式重新塑形。其中 [-1, 28, 28, 1]代表四维的tensor，分别为”[batch_size, width, height, channels]”，-1代表的含义是不用我们自己指定这一维的大小，函数会自动计算，但列表中只能存在一个-1。如果这里batch_size为5那么features将会含有3920个值，因为图片都是28<em>28的单色也就是1通道的输入，那么3920=5</em>28*28.</p>
<h4 id="卷积层1"><a href="#卷积层1" class="headerlink" title="卷积层1"></a>卷积层1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">conv1 = tf.layers.conv2d(</span><br><span class="line">    inputs=input_layer,</span><br><span class="line">    filters=32,</span><br><span class="line">    kernel_size=[5, 5],</span><br><span class="line">    padding=&quot;same&quot;,</span><br><span class="line">    activation=tf.nn.relu)</span><br></pre></td></tr></table></figure>
<p>输入是我们之前转化过的[-1, 28, 28, 1]shape的输入。<br>过滤器数目32个。<br>过滤器为5<em>5的（宽</em>高）。<br>padding一般只有两个值可选，valid(默认)这个会改变数据维度，比如28<em>28的input下内核为5</em>5经过卷积后变为了24*24，same这个通过在边缘添加0的方法不改变原有维度。<br>经过这步卷积处理后我们的输出变为了[batch_size,28，28，32]</p>
<h4 id="池化层1"><a href="#池化层1" class="headerlink" title="池化层1"></a>池化层1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool1 = tf.layers.max_pooling2d(inputs=conv1, pool_size=[2, 2], strides=2)</span><br></pre></td></tr></table></figure>
<p>输入为上一层的输出。<br>max池化过滤器的大小为2<em>2.每一个2</em>2的块里面去最大值。<br>步长为2，对于宽高可单独设置。步长为2意思是每次滑动长度为2，当前一个图片为28<em>28经过这个池化后就变为了14</em>14.<br>经过这步池化处理后输出变为[batch_size，14，14，32]</p>
<h4 id="卷积层2和池化层2"><a href="#卷积层2和池化层2" class="headerlink" title="卷积层2和池化层2"></a>卷积层2和池化层2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">conv2 = tf.layers.conv2d(</span><br><span class="line">    inputs=pool1,</span><br><span class="line">    filters=64,</span><br><span class="line">    kernel_size=[5, 5],</span><br><span class="line">    padding=&quot;same&quot;,</span><br><span class="line">    activation=tf.nn.relu)</span><br><span class="line"></span><br><span class="line">pool2 = tf.layers.max_pooling2d(inputs=conv2, pool_size=[2, 2], strides=2)</span><br></pre></td></tr></table></figure>
<p>经过卷积层2输出变为[batch_size，14，14，64]<br>经过池化层2输出变为[batch_size，7，7，64]    </p>
<h4 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool2_flat = tf.reshape(pool2, [-1, 7 * 7 * 64])</span><br></pre></td></tr></table></figure>
<p>我们首先将pool2的输出通过reshape变化为shape[batch_size, features]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dense = tf.layers.dense(inputs=pool2_flat, units=1024, activation=tf.nn.relu)</span><br></pre></td></tr></table></figure></p>
<p>通过dense()方法创建dense layer；<br>输入为pool2_flat<br>units为指定当前层神经元个数为1024<br>激活函数是ReLU<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dropout = tf.layers.dropout(</span><br><span class="line">    inputs=dense, rate=0.4, training=mode == tf.estimator.ModeKeys.TRAIN)</span><br></pre></td></tr></table></figure></p>
<p>加入dropout避免过拟合。<br>输出为[batch_size，1024]</p>
<h4 id="Logits-Layer"><a href="#Logits-Layer" class="headerlink" title="Logits Layer"></a>Logits Layer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logits = tf.layers.dense(inputs=dropout, units=10)</span><br></pre></td></tr></table></figure>
<p>输出为[batch_size,10]</p>
<h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>激活函数的作用是解决非线性问题。通常情况下我们使用单层感知机结构创建出一条线可以把一个平面分割成两块。如果我们使用多个感知机那么我们可以画多条线把平面分割，但这其实还是一个线性方程。也许你可以想象通过无数多个组合达到近似的曲线区分，那么恭喜你，这个想法“笨死了”。其实我们只需要在每层中加入一个激活函数就可以啦，比如<code>y = θ(a)</code>，这样就可以输出一个非线性函数了。</p>
<ul>
<li>tanh：双正切函数，取值范围[-1， 1]</li>
<li>sigmoid：S形函数，取值范围[-1，1]</li>
<li>ReLU：简单粗暴，大于0留下，否则一律为0</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/18/机器学习-11-通过MNIST了解卷积神经网络/" data-id="cjy3rwvu70003d2rgvbjklw3n" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-入门实践-鸢尾花分类问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/20/入门实践-鸢尾花分类问题/" class="article-date">
  <time datetime="2018-04-20T02:45:22.000Z" itemprop="datePublished">2018-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/20/入门实践-鸢尾花分类问题/">入门实践-鸢尾花分类问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在这里我们将会给出一个简单的预测问题的实现，并给出相应的讲解。</p>
<p>如果我们想实现预测功能，我们可以按以下步骤进行操作：</p>
<ul>
<li>导入和解析数据</li>
<li>创建特征用来描述数据</li>
<li>选择模型类型</li>
<li>训练模型</li>
<li>评估模型的效果</li>
<li>让经过训练的模型进行预测</li>
</ul>
<h3 id="导入数据："><a href="#导入数据：" class="headerlink" title="导入数据："></a>导入数据：</h3><p>下载地址定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TRAIN_URL = &quot;http://download.tensorflow.org/data/iris_training.csv&quot;</span><br><span class="line">TEST_URL = &quot;http://download.tensorflow.org/data/iris_test.csv&quot;</span><br></pre></td></tr></table></figure></p>
<p>Feature定义，这个要根据训练数据定的。CSV_COLUMN_NAMES对应的feature，species对应的label。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSV_COLUMN_NAMES = [&apos;SepalLength&apos;, &apos;SepalWidth&apos;,</span><br><span class="line">                    &apos;PetalLength&apos;, &apos;PetalWidth&apos;, &apos;Species&apos;]</span><br><span class="line"></span><br><span class="line">SPECIES = [&apos;Setosa&apos;, &apos;Versicolor&apos;, &apos;Virginica&apos;]</span><br></pre></td></tr></table></figure></p>
<p>下载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def maybe_download():</span><br><span class="line">    train_path = tf.keras.utils.get_file(TRAIN_URL.split(&apos;/&apos;)[-1], TRAIN_URL)</span><br><span class="line">    test_path = tf.keras.utils.get_file(TEST_URL.split(&apos;/&apos;)[-1], TEST_URL)</span><br><span class="line"></span><br><span class="line">    return train_path, test_path</span><br></pre></td></tr></table></figure></p>
<p>加载数据。先下载下来，这里的下载文件是csv，然后进行读取，最后分别输出feature和标签。当然这里需要处理训练数据和测试数据两块数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def load_data(y_name=&apos;Species&apos;):</span><br><span class="line">    &quot;&quot;&quot;Returns the iris dataset as (train_x, train_y), (test_x, test_y).&quot;&quot;&quot;</span><br><span class="line">    train_path, test_path = maybe_download()</span><br><span class="line"></span><br><span class="line">    train = pd.read_csv(train_path, names=CSV_COLUMN_NAMES, header=0)</span><br><span class="line">    train_x, train_y = train, train.pop(y_name)</span><br><span class="line"></span><br><span class="line">    test = pd.read_csv(test_path, names=CSV_COLUMN_NAMES, header=0)</span><br><span class="line">    test_x, test_y = test, test.pop(y_name)</span><br><span class="line"></span><br><span class="line">    return (train_x, train_y), (test_x, test_y)</span><br></pre></td></tr></table></figure></p>
<p>把数据转换成训练可用的数据格式Dataset，其中<code>from_tensor_slices</code>方法的作用是在输入的数据的第一个维度上进行分片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def train_input_fn(features, labels, batch_size):</span><br><span class="line">    &quot;&quot;&quot;An input function for training&quot;&quot;&quot;</span><br><span class="line">    # Convert the inputs to a Dataset.</span><br><span class="line">    dataset = tf.data.Dataset.from_tensor_slices((dict(features), labels))</span><br><span class="line"></span><br><span class="line">    # Shuffle, repeat, and batch the examples.</span><br><span class="line">    dataset = dataset.shuffle(1000).repeat().batch(batch_size)</span><br><span class="line"></span><br><span class="line">    # Return the dataset.</span><br><span class="line">    return dataset</span><br><span class="line">    </span><br><span class="line">def eval_input_fn(features, labels, batch_size):</span><br><span class="line">    &quot;&quot;&quot;An input function for evaluation or prediction&quot;&quot;&quot;</span><br><span class="line">    features=dict(features)</span><br><span class="line">    if labels is None:</span><br><span class="line">        # No labels, use only features.</span><br><span class="line">        inputs = features</span><br><span class="line">    else:</span><br><span class="line">        inputs = (features, labels)</span><br><span class="line"></span><br><span class="line">    # Convert the inputs to a Dataset.</span><br><span class="line">    dataset = tf.data.Dataset.from_tensor_slices(inputs)</span><br><span class="line"></span><br><span class="line">    # Batch the examples</span><br><span class="line">    assert batch_size is not None, &quot;batch_size must not be None&quot;</span><br><span class="line">    dataset = dataset.batch(batch_size)</span><br><span class="line"></span><br><span class="line">    # Return the dataset.</span><br><span class="line">    return dataset</span><br></pre></td></tr></table></figure></p>
<h3 id="创建特征用来描述数据"><a href="#创建特征用来描述数据" class="headerlink" title="创建特征用来描述数据"></a>创建特征用来描述数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_feature_columns = [</span><br><span class="line">    tf.feature_column.numeric_column(key=&apos;SepalLength&apos;),</span><br><span class="line">    tf.feature_column.numeric_column(key=&apos;SepalWidth&apos;),</span><br><span class="line">    tf.feature_column.numeric_column(key=&apos;PetalLength&apos;),</span><br><span class="line">    tf.feature_column.numeric_column(key=&apos;PetalWidth&apos;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="选择模型类型"><a href="#选择模型类型" class="headerlink" title="选择模型类型"></a>选择模型类型</h3><p>tensorflow支持两种创建模型，一种是已经为大家封装好的，一种是自定义的。下面使用的是封装好的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classifier = tf.estimator.DNNClassifier(</span><br><span class="line">        feature_columns=my_feature_columns,</span><br><span class="line">        hidden_units=[10, 10],</span><br><span class="line">        n_classes=3)</span><br></pre></td></tr></table></figure></p>
<h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classifier.train(</span><br><span class="line">        input_fn=lambda: Iris_data.train_input_fn(train_x, train_y,</span><br><span class="line">                                                  args.batch_size),</span><br><span class="line">        steps=args.train_steps)</span><br></pre></td></tr></table></figure>
<h3 id="评估模型的效果"><a href="#评估模型的效果" class="headerlink" title="评估模型的效果"></a>评估模型的效果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eval_result = classifier.evaluate(</span><br><span class="line">        input_fn=lambda: Iris_data.eval_input_fn(test_x, test_y,</span><br><span class="line">                                                 args.batch_size))</span><br></pre></td></tr></table></figure>
<h3 id="进行预测"><a href="#进行预测" class="headerlink" title="进行预测"></a>进行预测</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">expected = [&apos;Setosa&apos;, &apos;Versicolor&apos;, &apos;Virginica&apos;]</span><br><span class="line"></span><br><span class="line">    predict_x = &#123;</span><br><span class="line">        &apos;SepalLength&apos;: [5.1, 5.9, 6.9],</span><br><span class="line">        &apos;SepalWidth&apos;: [3.3, 3.0, 3.1],</span><br><span class="line">        &apos;PetalLength&apos;: [1.7, 4.2, 5.4],</span><br><span class="line">        &apos;PetalWidth&apos;: [0.5, 1.5, 2.1],</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    predictions = classifier.predict(</span><br><span class="line">        input_fn=lambda: Iris_data.eval_input_fn(predict_x,</span><br><span class="line">                                                 labels=None,</span><br><span class="line">                                                 batch_size=args.batch_size))</span><br><span class="line"></span><br><span class="line">    template = (&apos;\nPrediction is &quot;&#123;&#125;&quot; (&#123;:.1f&#125;%), expected &quot;&#123;&#125;&quot;&apos;)</span><br><span class="line"></span><br><span class="line">    for pred_dict, expec in zip(predictions, expected):</span><br><span class="line">        class_id = pred_dict[&apos;class_ids&apos;][0]</span><br><span class="line">        probability = pred_dict[&apos;probabilities&apos;][class_id]</span><br><span class="line"></span><br><span class="line">        print(template.format(Iris_data.SPECIES[class_id],</span><br><span class="line">                              100 * probability, expec))</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/20/入门实践-鸢尾花分类问题/" data-id="cjy3rwvu10001d2rgfe5shl16" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-机器学习—10-特征缩放和学习率" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/30/机器学习—10-特征缩放和学习率/" class="article-date">
  <time datetime="2018-03-30T02:22:09.000Z" itemprop="datePublished">2018-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/30/机器学习—10-特征缩放和学习率/">机器学习—10 特征缩放和学习率</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="特征缩放和学习率"><a href="#特征缩放和学习率" class="headerlink" title="特征缩放和学习率"></a>特征缩放和学习率</h2><p>在梯度下降的算法中，我们有一些方法可以加速梯度下降，接下来我们就介绍下，特征缩放和学习率。</p>
<h3 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h3><p>我们先回忆下公式：</p>
<script type="math/tex; mode=display">
\begin{align*} \text{repeat until convergence:} \\ \lbrace & \\ \theta_0 := & \theta_0 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m}(h_\theta(x_{i}) - y_{i}) \\ \theta_1 := & \theta_1 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m}\left((h_\theta(x_{i}) - y_{i}) x_{i}\right) \\ \rbrace& \end{align*}</script><p>对于θ，在小范围内下降比较快，在大范围内下降比较慢。所以如果这些变量不均匀时算法会比较低效。<br>通过上面的原因，我们可以认为的控制参数范围，从而避免比较低效的状况。<br>比如令参数：<br>-1 &lt;=$x_{(i)}$ &lt;= 1或者 -0.5 &lt;= $x_{(i)}$&lt;=0.5</p>
<p>当然这些都不是固定的，只要满足我们能够快速下降就可以了。</p>
<p>我们可以用两种技术实现，特征缩放和平均归一。</p>
<p>特征缩放：每个输入值除以最大输入减去最小输入，平均值为1。（输入值/（最大-最小））</p>
<p>平均归一：每个输入减去输入平均值，平均值为0。</p>
<p>根据上面两个方法，我们可以总结出以下公式：</p>
<script type="math/tex; mode=display">
x_i := \dfrac{x_i - \mu_i}{s_i}</script><p>公式右边：</p>
<p>$x_i$是第i个参数的输入值；$\mu_i$是第i个参数的平均值；$s_i$是标准差，即最大值减最小值。<br>例如：<br>$x_i$的区间是100到2000。平均值为1000.那么公式就是：</p>
<script type="math/tex; mode=display">
x_i := \dfrac{price-1000}{1900}</script><h3 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h3><ol>
<li>首先我们会了解，如何判断我们的梯度下降是正确的。</li>
<li>如何选择学习率α。</li>
</ol>
<p>如果你将代价函数J(θ)做为纵坐标系，迭代步数作为很坐标系。</p>
<ol>
<li>你发现随着迭代步数增加，你的J(θ)是一直减小的，那么说明你的梯度下降是工作的。</li>
<li>如果你发现随着迭代步数增加，你的J(θ)变大了，这时候你需要减小你的学习率α了。</li>
<li>如果你发现随着迭代步数增加，你的J(θ)减小小于$10^{-3}$ ,说明收敛<br>另外对于学习率的选择，</li>
<li>如果学习率太大，可能就不能收敛，也就是失败了。</li>
<li>如果学习率太小，可能收敛太慢，需要的迭代步数变得非常多。 </li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/30/机器学习—10-特征缩放和学习率/" data-id="cjy3rwvug0006d2rgravdn3lt" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-机器学习—9-多参的梯度下降" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/30/机器学习—9-多参的梯度下降/" class="article-date">
  <time datetime="2018-03-30T02:18:44.000Z" itemprop="datePublished">2018-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/30/机器学习—9-多参的梯度下降/">机器学习—9 多参的梯度下降</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="多参"><a href="#多参" class="headerlink" title="多参"></a>多参</h3><p>在之前我们所举例子是两个参数</p>
<script type="math/tex; mode=display">
h_\theta(x) = \theta_0x_0 + \theta_1x_1;</script><p>但是在实际需求中这样的公式肯定不是两个参数可以解决的，那么我么就来假设一个多参的公式：</p>
<script type="math/tex; mode=display">
h_\theta(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 + \theta_3x_3 + ... + \theta_nx_n</script><p>转换成矩阵运算就是：</p>
<script type="math/tex; mode=display">
\begin{align*}h_\theta(x) =\begin{bmatrix}\theta_0 \hspace{2em} \theta_1 \hspace{2em} ... \hspace{2em} \theta_n\end{bmatrix}\begin{bmatrix}x_0 \newline x_1 \newline \vdots \newline x_n\end{bmatrix}= \theta^T x\end{align*}</script><h3 id="多参的梯度下降"><a href="#多参的梯度下降" class="headerlink" title="多参的梯度下降"></a>多参的梯度下降</h3><script type="math/tex; mode=display">
\begin{align*} & \text{repeat until convergence:} \; \lbrace \newline \; & \theta_0 := \theta_0 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_0^{(i)}\newline \; & \theta_1 := \theta_1 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_1^{(i)} \newline \; & \theta_2 := \theta_2 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_2^{(i)} \newline & \cdots \newline \rbrace \end{align*}</script><p>换种表达方式：</p>
<script type="math/tex; mode=display">
\begin{align*}& \text{repeat until convergence:} \; \lbrace \newline \; & \theta_j := \theta_j - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_j^{(i)} \; & \text{for j := 0...n}\newline \rbrace\end{align*}</script>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/30/机器学习—9-多参的梯度下降/" data-id="cjy3rwvv6000dd2rgdnfd9jof" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-机器学习—8-Octave工具" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/08/机器学习—8-Octave工具/" class="article-date">
  <time datetime="2018-03-08T12:59:53.000Z" itemprop="datePublished">2018-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/08/机器学习—8-Octave工具/">机器学习—8 Octave工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Octave是一款用于数值计算和绘图的开源软件。</p>
<p>首先打开Mac系统的System Preferences，点开Security &amp; Privacy，选择允许在任意地方下载app。</p>
<p>下载<a href="http://sourceforge.net/projects/octave/files/Octave%20MacOSX%20Binary/2013-12-30%20binary%20installer%20of%20Octave%203.8.0%20for%20OSX%2010.9.1%20%28beta%29/GNU_Octave_3.8.0-6.dmg/download" target="_blank" rel="noopener">Octave</a>，下载完毕后点击打开，按步骤安装</p>
<p>安装完毕后你可以在mac电脑上看到<code>*Octave-cli*</code>。</p>
<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><ul>
<li>简单运算：5+6， 5*6， 5^6</li>
<li>逻辑运算：1 == 2  % false(百分号是注释)； 1 &amp;&amp; 0 ;1||0;xor(1, 0)</li>
<li>赋值语句：a = 5</li>
<li><p>强制转换形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = pi</span><br><span class="line">format long</span><br><span class="line">format short</span><br></pre></td></tr></table></figure>
</li>
<li><p>矩阵</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = [1 2; 3 4; 5 6]</span><br></pre></td></tr></table></figure>
</li>
<li><p>矢量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = [1 2 3]</span><br></pre></td></tr></table></figure>
</li>
<li><p>v = 1.0:0.2:2.0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.00 1.20 1.40 1.60 1.80 2.00</span><br></pre></td></tr></table></figure>
</li>
<li><p>v = 1:5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>
</li>
<li><p>one(2, 3)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>2 * one(2, 3)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 2 2</span><br><span class="line">2 2 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>randn(3, 3): 生成3 * 3 元素是高斯随机变量<br>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w = -6 + sqrt(10) * (randn(1, 1000))</span><br></pre></td></tr></table></figure>
</li>
<li><p>hist(w):绘制成图</p>
</li>
<li>eye(4):获取到四行四列的单位矩阵</li>
<li>size(A):获取矩阵A的行列；size(A,1)矩阵的行；size(A, 2)矩阵的列</li>
<li>pwd是当前所处路径，加载本地文件使用load()；显示当前内存的变量使用who，whos更详细的内容。</li>
<li>保存：save helo.mat A；把A保存到helo.mat的文件中。save helo.txt A -ascii</li>
<li>A(2, :):第二行所有元素；A(:, 2):第二列所有元素；A([1,3], :):第一行第三行所有元素</li>
<li>A(:)所有行列元素列出来</li>
<li>​<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">												          1  2</span><br><span class="line">    1 2       11 12              1 2 11 12				  3  4		</span><br><span class="line">A = 3 4   B = 13 14  C = [A B] = 3 4 13 14  D = [A ; B] = 5  6</span><br><span class="line">    5 6       15 16              5 6 15 16                11 12</span><br><span class="line">    													  13 14</span><br><span class="line">    													  15 16</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	1 2		 1 1			5  5</span><br><span class="line">A = 3 4  C = 2 2    A * C = 11 11</span><br><span class="line">	5 6 					17 17</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	1 2		 11 12			 11 24</span><br><span class="line">A = 3 4  B = 13 14  A .* B = 39 56</span><br><span class="line">	5 6		 15 16			 75 96</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	1 2			 1  2			  1		0.5</span><br><span class="line">A = 3 4  A .^2 = 9  16   1 ./ A = 0.333 0.25</span><br><span class="line">	5 6			 25 36			  0.2   0.167</span><br></pre></td></tr></table></figure>
<p>还有类似的运算<code>log(A)</code>, <code>exp(A)</code>, <code>abs(A)</code>, <code>A&#39;</code>, <code>max(A)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[val, ind] = max(A); val = 6; ind = 5</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = [1 , 2 , 3];  a &lt; 2 = 1 0 0; find(a &lt; 2) = 1</span><br></pre></td></tr></table></figure>
<p>magic(3):生成一个三行三列的任何行列相加都相等的矩阵<br>max(rand(3),rand(3) )   %将会返回一个3<em>3的矩阵，每一个元素都是随机生成的矩阵对应的两个元素的最大值<br>max(A,[],1)                       %将会返回一个行矩阵，是A中每一列的最大值<br>max(A,[],2)                       %将会返回一个列矩阵，是A中每一行的最大值<br>max(A)                              %是对每一列求出最大值<br>max(max(A))                    %求矩阵的最大值 或是也可以先把矩阵变成列 A(:)  然后求max，max（A(:)）<br>sum(a)   prod(a) floor(a)  ceil(a)        %<br>sum(A,1)        %表示对每一行求所有元素的和<br>sum(A,2)        %表示对每一列求所有元素的和<br>sum(sum(A.</em>eye(9)))    %求出A的对角线之和</p>
<h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化:"></a>数据可视化:</h3><p>t=[0:0.01:0.98];<br>y1=sin(8<em>pi</em>t);<br>y2=cos(8<em>pi</em>t);<br>plot(t,y1);<br>hold on;<br>plot(t,y2,’r’);<br>xlabel(‘time’);<br>ylabel(‘value’);<br>title(‘my plot’);<br>legend(‘sin’,’cos’);<br>cd ‘D:\’;print -dpng ‘myPng’;<br>close  %close the figure</p>
<h3 id="for-while-if-statements-and-functions"><a href="#for-while-if-statements-and-functions" class="headerlink" title="for, while, if statements, and functions"></a>for, while, if statements, and functions</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">v = zeros(10, 1);</span><br><span class="line">for i=1:10</span><br><span class="line">	v(i) = 2^i;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = 1;</span><br><span class="line">while i &lt;= 5</span><br><span class="line">	v(i) = 100;</span><br><span class="line">	i = i+1;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">i = 1;</span><br><span class="line">while true</span><br><span class="line">	v(i) = 999;</span><br><span class="line">	i = i + 1;</span><br><span class="line">	if i == 6</span><br><span class="line">		break;</span><br><span class="line">	end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if v[1] == 1</span><br><span class="line">	disp(&apos;The value is one&apos;)</span><br><span class="line">elseif v[1] == 2</span><br><span class="line">	disp(&apos;The value is two&apos;)</span><br><span class="line">else</span><br><span class="line">	disp(&apos;The value is other&apos;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%Function</span><br><span class="line">function r = squareThisNumber(x)</span><br><span class="line">	r = x * x</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function [a, b] = squareThisNumber(x)</span><br><span class="line">	a = x * x</span><br><span class="line">	b = x * x * x</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>OK,就到这里。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/08/机器学习—8-Octave工具/" data-id="cjy3rwvuw000cd2rgux7fqrq6" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-机器学习—7-相关数学计算" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/04/机器学习—7-相关数学计算/" class="article-date">
  <time datetime="2018-03-04T02:20:28.000Z" itemprop="datePublished">2018-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/04/机器学习—7-相关数学计算/">机器学习—7 相关数学计算</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>矩阵：</p>
<script type="math/tex; mode=display">
\left[
\begin{matrix}
a & b & c\\
d & e & f\\
g & h & i
\end{matrix} 
\right]</script><p>向量：</p>
<script type="math/tex; mode=display">
\left[
\begin{matrix}
a\\
b\\
c
\end{matrix}
\right]</script><p>矩阵加法：</p>
<script type="math/tex; mode=display">
\begin{bmatrix} a & b \\ c & d \end{bmatrix} +\begin{bmatrix} w & x \\ y & z \end{bmatrix} =\begin{bmatrix} a+w & b+x \\ c+y & d+z \end{bmatrix}</script><p>矩阵减法：</p>
<script type="math/tex; mode=display">
\begin{bmatrix} a & b \\ c & d \end{bmatrix} - \begin{bmatrix} w & x \\ y & z \end{bmatrix} =\begin{bmatrix} a-w & b-x \\ c-y & d-z \end{bmatrix}</script><p>矩阵乘法：</p>
<script type="math/tex; mode=display">
\begin{bmatrix} a & b \\ c & d \end{bmatrix} * x =\begin{bmatrix} a*x & b*x \\ c*x & d*x \end{bmatrix}</script><p>矩阵除法：</p>
<script type="math/tex; mode=display">
\begin{bmatrix} a & b \\ c & d \end{bmatrix} / x =\begin{bmatrix} a /x & b/x \\ c /x & d /x \end{bmatrix}</script><p>矩阵向量乘法：</p>
<script type="math/tex; mode=display">
\begin{bmatrix} a & b \\ c & d \\ e & f \end{bmatrix} *\begin{bmatrix} x \\ y \end{bmatrix} =\begin{bmatrix} a*x + b*y \\ c*x + d*y \\ e*x + f*y \end{bmatrix}</script><p>矩阵矩阵乘法：</p>
<script type="math/tex; mode=display">
\begin{bmatrix} a & b \\ c & d \\ e & f \end{bmatrix} *\begin{bmatrix} w & x \\ y & z \end{bmatrix} =\begin{bmatrix} a*w + b*y & a*x + b*z \\ c*w + d*y & c*x + d*z \\ e*w + f*y & e*x + f*z\end{bmatrix}</script><p>Identity Matrix:</p>
<script type="math/tex; mode=display">
\left[
\begin{matrix} 
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{matrix}
\right]</script><p>矩阵的逆</p>
<script type="math/tex; mode=display">
AA^{-1}=A^{-1}A=I</script><p>矩阵的转置</p>
<script type="math/tex; mode=display">
A = \begin{bmatrix} a & b & c \\ d & e & f \end{bmatrix}
A^T = \begin{bmatrix} a & d \\ b & e \\ c & f \end{bmatrix}</script><p>OK, 就这些了！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/04/机器学习—7-相关数学计算/" data-id="cjy3rwvut000bd2rgtgzyw5uv" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/算法/" style="font-size: 10px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/14/Git使用教程/">Git使用教程</a>
          </li>
        
          <li>
            <a href="/2018/11/12/Jetpack/">Jetpack</a>
          </li>
        
          <li>
            <a href="/2018/10/09/算法/">算法</a>
          </li>
        
          <li>
            <a href="/2018/10/03/数据结构/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/05/18/机器学习-11-通过MNIST了解卷积神经网络/">机器学习-11-通过MNIST了解卷积神经网络</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 XiaoYang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>